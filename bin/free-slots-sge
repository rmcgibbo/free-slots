#!/usr/bin/python
import getpass
import subprocess
from collections import defaultdict
from collections import namedtuple
from distutils.spawn import find_executable
import xml.etree.ElementTree as ET

status = namedtuple('status', ['queue', 'np_alloc', 'np_total'])
QHOST_BIN = find_executable('qhost')
QCONF_BIN = find_executable('qconf')
ALL_USERS = object()


def parse_qconf(cmd):
    proc = subprocess.Popen([QCONF_BIN] + cmd.split(), stdout=subprocess.PIPE)
    stdout, _ = proc.communicate()
    assert proc.poll() == 0

    lines = stdout.splitlines()
    if len(lines[0].split()) == 1:
        # this looks like just a list
        return [e.strip() for e in lines]

    # otherwise, we have a mapping
    out = {}
    lines = iter(lines)
    for line in lines:
        key, value = [e.strip() for e in line.split(' ', 1)]
        value = value.strip('\\ ')
        while line.endswith('\\'):
            line = next(lines)
            value += line.strip('\\ ')
        out[key] = value
    return out


def queue_allowed():
    def permitted_queue(queue, user=None):
        if user is None:
            user = getpass.getuser()

        ulists = parse_qconf('-sq %s' % queue)['user_lists']
        if ulists == 'NONE':
            return True
        return user in parse_qconf('-su %s' % ulists)['entries']

    queues = parse_qconf('-sql')
    return dict((q, permitted_queue(q)) for q in queues)


def collect():
    allowed_by_queue = queue_allowed()
    proc = subprocess.Popen([QHOST_BIN, '-q',  '-xml'],
                            stdout=subprocess.PIPE)
    stdout, _ = proc.communicate()
    root = ET.fromstring(stdout)
    count = defaultdict(lambda: 0)

    for host in root.findall('host'):
        queue = host.find('queue')
        if queue is None:
            continue
        if not allowed_by_queue[queue.attrib['name']]:
            continue
        qvalues = dict((q.attrib['name'], q.text)
                       for q in queue.findall("queuevalue"))

        s = status(queue.attrib['name'],
                   int(qvalues['slots_used']),
                   int(qvalues['slots']))
        count[s] += 1

    return dict(count)


def format_table(rows):
    cols = zip(*rows)
    col_widths = [max(len(str(value))+2 for value in col) for col in cols]
    format = ' '.join(['%%-%ds' % width for width in col_widths ])
    lines = []
    for row in rows:
        lines.append(format % tuple(row))
    return '\n'.join(lines)


def main():
    count = collect()
    lines = [['Number of nodes', 'Queue', 'Utilization', 'Free slots']]
    lines.append(['-'*len(e) for e in lines[0]])
    for k in sorted(count.keys(), key=lambda c: c.queue):
        if k.np_total == k.np_alloc:
            continue
        lines.append([count[k], k.queue, '%s/%s' % (k.np_alloc, k.np_total), k.np_total-k.np_alloc])

    print('Summary of SGE nodes with free slots\n')
    print(format_table(lines))


if __name__ == '__main__':
    main()
